<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Rust系列（一）：从零开始 | Sansen Sekai</title>
    <meta name="description" content="三千世界, 学无止境">
    <link rel="shortcut icon" type="image/x-icon" href="./public/sad-me.png">
    
    <link rel="preload" href="/assets/css/0.styles.56fe4379.css" as="style"><link rel="preload" href="/assets/js/app.3b644823.js" as="script"><link rel="preload" href="/assets/js/2.e997199f.js" as="script"><link rel="preload" href="/assets/js/30.a266a056.js" as="script"><link rel="prefetch" href="/assets/js/10.5ee0a82c.js"><link rel="prefetch" href="/assets/js/11.daee2873.js"><link rel="prefetch" href="/assets/js/12.8248456d.js"><link rel="prefetch" href="/assets/js/13.54a5dd4a.js"><link rel="prefetch" href="/assets/js/14.b823f735.js"><link rel="prefetch" href="/assets/js/15.d3b5d7cb.js"><link rel="prefetch" href="/assets/js/16.be4ba155.js"><link rel="prefetch" href="/assets/js/17.c61f081b.js"><link rel="prefetch" href="/assets/js/18.27973658.js"><link rel="prefetch" href="/assets/js/19.12894926.js"><link rel="prefetch" href="/assets/js/20.b2251d91.js"><link rel="prefetch" href="/assets/js/21.9368ff97.js"><link rel="prefetch" href="/assets/js/22.c5dd3b56.js"><link rel="prefetch" href="/assets/js/23.823a011e.js"><link rel="prefetch" href="/assets/js/24.133dc402.js"><link rel="prefetch" href="/assets/js/25.908d76af.js"><link rel="prefetch" href="/assets/js/26.50ae55c2.js"><link rel="prefetch" href="/assets/js/27.4d3bdc40.js"><link rel="prefetch" href="/assets/js/28.1910ec53.js"><link rel="prefetch" href="/assets/js/29.ae3971d2.js"><link rel="prefetch" href="/assets/js/3.8119daf4.js"><link rel="prefetch" href="/assets/js/31.6e1332a3.js"><link rel="prefetch" href="/assets/js/32.d43f6148.js"><link rel="prefetch" href="/assets/js/33.9f60066d.js"><link rel="prefetch" href="/assets/js/34.89e76bff.js"><link rel="prefetch" href="/assets/js/35.976d89b0.js"><link rel="prefetch" href="/assets/js/36.70cb64a6.js"><link rel="prefetch" href="/assets/js/37.5a73ef0e.js"><link rel="prefetch" href="/assets/js/38.c74c2711.js"><link rel="prefetch" href="/assets/js/39.8e716e3c.js"><link rel="prefetch" href="/assets/js/4.5292c871.js"><link rel="prefetch" href="/assets/js/40.64191991.js"><link rel="prefetch" href="/assets/js/41.118c8402.js"><link rel="prefetch" href="/assets/js/42.7c764675.js"><link rel="prefetch" href="/assets/js/43.6cade1e6.js"><link rel="prefetch" href="/assets/js/44.615aeebf.js"><link rel="prefetch" href="/assets/js/45.acfd3be9.js"><link rel="prefetch" href="/assets/js/46.5e409128.js"><link rel="prefetch" href="/assets/js/5.69e3b9fc.js"><link rel="prefetch" href="/assets/js/6.36a28e4b.js"><link rel="prefetch" href="/assets/js/7.708932b7.js"><link rel="prefetch" href="/assets/js/8.288108ab.js"><link rel="prefetch" href="/assets/js/9.377be857.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56fe4379.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Sansen Sekai</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/essay/" class="nav-link router-link-active">技术杂文</a></div><div class="nav-item"><a href="/base/" class="nav-link">基础知识</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法解析</a></div><div class="nav-item"><a href="https://github.com/sad-xu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/essay/" class="nav-link router-link-active">技术杂文</a></div><div class="nav-item"><a href="/base/" class="nav-link">基础知识</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法解析</a></div><div class="nav-item"><a href="https://github.com/sad-xu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/essay/" class="sidebar-link">技术杂文</a></li><li><a href="/essay/canvas的艺术.html" class="sidebar-link">canvas的艺术</a></li><li><a href="/essay/纯CSS实现酷炫文字效果.html" class="sidebar-link">纯CSS实现酷炫文字效果</a></li><li><a href="/essay/Highcharts多图联动实现及优化.html" class="sidebar-link">Highcharts多图联动实现及优化</a></li><li><a href="/essay/导出图片和excel实践.html" class="sidebar-link">导出图片和Excel实践</a></li><li><a href="/essay/Highcharts矩形树图的自定义布局方法.html" class="sidebar-link">Highcharts矩形树图的自定义布局方法</a></li><li><a href="/essay/第一届缤纷-滨江前端技术沙龙总结与感想.html" class="sidebar-link">第一届缤纷-滨江前端技术沙龙总结与感想</a></li><li><a href="/essay/前端代码埋点实践（二）.html" class="sidebar-link">前端代码埋点实践（二）</a></li><li><a href="/essay/前端代码埋点实践.html" class="sidebar-link">前端代码埋点实践</a></li><li><a href="/essay/Rust系列（一）.html" class="active sidebar-link">Rust系列（一）：从零开始</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#windows安装" class="sidebar-link">Windows安装</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#新建项目" class="sidebar-link">新建项目</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#cargo-构建系统和包管理器" class="sidebar-link">cargo 构建系统和包管理器</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#基础" class="sidebar-link">基础</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#所有权-ownership" class="sidebar-link">所有权 ownership</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#结构体-struct" class="sidebar-link">结构体 struct</a></li><li class="sidebar-sub-header"><a href="/essay/Rust系列（一）.html#枚举-enums" class="sidebar-link">枚举 enums</a></li></ul></li><li><a href="/essay/Rust系列（二）.html" class="sidebar-link">Rust系列（二）</a></li><li><a href="/essay/初探Rust与WASM.html" class="sidebar-link">初试WASM与Rust</a></li><li><a href="/essay/深度解析异步串行的4种实现及区别.html" class="sidebar-link">深度解析异步串行的4种实现及区别</a></li><li><a href="/essay/SVG图标在项目中的使用.html" class="sidebar-link">SVG图标在项目中的使用</a></li><li><a href="/essay/神策数据前端埋点源码解读.html" class="sidebar-link">神策数据前端埋点源码不完全解读</a></li><li><a href="/essay/vue-cli3移动端项目配置不完全指南.html" class="sidebar-link">vue-cli3移动端项目配置不完全指南</a></li><li><a href="/essay/用js让CPU跑出一个阿姆斯特朗回旋加速喷气式阿姆斯特朗炮.html" class="sidebar-link">用js让CPU跑出一个阿姆斯特朗回旋加速喷气式阿姆斯特朗炮</a></li><li><a href="/essay/Vue组件命令式和声明式的使用方式.html" class="sidebar-link">Vue组件命令式和声明式的使用方式</a></li><li><a href="/essay/优雅灵活的前端权限控制实践.html" class="sidebar-link">优雅灵活的前端权限控制实践</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="rust系列（一）：从零开始"><a href="#rust系列（一）：从零开始" class="header-anchor">#</a> Rust系列（一）：从零开始</h1> <h2 id="windows安装"><a href="#windows安装" class="header-anchor">#</a> Windows安装</h2> <ol><li><p>官网<a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="noopener noreferrer">https://www.rust-lang.org/zh-CN/tools/install<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>安装<code>rust-init.exe</code></p></li> <li><p>国内环境直接安装会很慢甚至超时，需要增加两个环境变量</p> <p><code>RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup</code></p> <p><code>RUSTUP_UPDATE_ROOT=http://mirrors.ustc.edu.cn/rust-static/rustup</code></p></li> <li><p>验证是否安装成功 <code>rustc --version</code></p></li> <li><p>crates镜像</p> <p>类似npm的镜像，提高下依赖时的速度，在<code>C:\Users\Administrator\.cargo</code>里新建<code>config</code>文件</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">[</span>source.crates-io<span class="token punctuation">]</span>
registry <span class="token operator">=</span> <span class="token string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span>
replace-with <span class="token operator">=</span> <span class="token string">'ustc'</span>
<span class="token punctuation">[</span>source.ustc<span class="token punctuation">]</span>
registry <span class="token operator">=</span> <span class="token string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span>
</code></pre></div></li></ol> <h2 id="新建项目"><a href="#新建项目" class="header-anchor">#</a> 新建项目</h2> <ol><li><p>编译</p> <p>新建<code>hello_world.rs</code>文件</p> <div class="language-rs extra-class"><pre class="language-text"><code>fn main() {
  printn!(&quot;Hello World!&quot;)
}
</code></pre></div><p>命令行执行<code>rustc hello_world.rs</code>，生成两个文件<code>hello_world.exe</code>和<code>hello_world.pdd</code></p></li> <li><p>运行</p> <p><code>.pdd</code>包含调试信息，执行<code>.exe</code>，输出<code>Hello World!</code></p></li></ol> <h2 id="cargo-构建系统和包管理器"><a href="#cargo-构建系统和包管理器" class="header-anchor">#</a> cargo 构建系统和包管理器</h2> <p>初始化项目</p> <div class="language-bash extra-class"><pre class="language-bash"><code>cargo new hello_cargo
<span class="token builtin class-name">cd</span> hello_cargo
</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code><span class="token operator">|</span> .gitignore
<span class="token operator">|</span> Cargo.toml
<span class="token punctuation">\</span>---.git
<span class="token punctuation">\</span>---src
    main.rs
</code></pre></div><p>通过 Cargo 构建</p> <div class="language-bash extra-class"><pre class="language-bash"><code>cargo build
</code></pre></div><p>发布构建</p> <div class="language-bash extra-class"><pre class="language-bash"><code>cargo build --release
</code></pre></div><p>编译并运行</p> <div class="language-bash extra-class"><pre class="language-bash"><code>cargo run
</code></pre></div><p>检查代码确保可编译</p> <div class="language-bash extra-class"><pre class="language-bash"><code>cargo check
</code></pre></div><p>更新依赖版本</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 只更新小版本 修改Cargo.lock文件</span>
cargo update
</code></pre></div><p>生成当前依赖的文档</p> <div class="language-bash extra-class"><pre class="language-bash"><code>cargo doc --open
</code></pre></div><hr> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <h3 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h3> <h4 id="普通注释"><a href="#普通注释" class="header-anchor">#</a> 普通注释</h4> <div class="language-rs extra-class"><pre class="language-text"><code>// 单行注释
/* 多行注释 */
</code></pre></div><h4 id="文档注释"><a href="#文档注释" class="header-anchor">#</a> 文档注释</h4> <div class="language-rs extra-class"><pre class="language-text"><code>/// 为下面的项生成帮助文档
//! 为注释所属项生成帮助文档
</code></pre></div><h3 id="格式化输出"><a href="#格式化输出" class="header-anchor">#</a> 格式化输出</h3> <p><code>std::fmt</code>里定义的一系列宏</p> <p><code>format!</code>,<code>print!</code>,<code>println!</code>,<code>eprint!</code>,<code>eprintln!</code></p> <hr> <h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <p>几乎所有编程语言都共通的概念</p> <h3 id="变量和可变性"><a href="#变量和可变性" class="header-anchor">#</a> 变量和可变性</h3> <p><code>let</code> 声明变量，默认不可变；<code>let mut</code>声明的变量可变</p> <p><code>const</code> 声明常量</p> <p><code>shadowing</code>: 隐藏，多次定义同名变量，实际上创建了新的变量，可改变类型</p> <p><code>mut</code>: 未创建新变量，无法改变类型</p> <h3 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h3> <p>数据类型 = 标量 scalar + 复合 compound</p> <p>标量 = 整型 + 浮点型 + 布尔类型 + 字符类型</p> <p>复合 = 元祖 tuple + 数组 array</p> <h4 id="整型"><a href="#整型" class="header-anchor">#</a> 整型</h4> <p>默认<code>i32</code></p> <p>范围<code>-2^(n - 1) 或 0 到 2(n - 1) - 1</code></p> <table><thead><tr><th>长度</th> <th>有符号</th> <th>无符号</th> <th>大小</th></tr></thead> <tbody><tr><td>8-bit</td> <td>i8</td> <td>u8</td> <td>128</td></tr> <tr><td>16-bit</td> <td>i16</td> <td>u16</td> <td>32768</td></tr> <tr><td>32-bit</td> <td>i32</td> <td>u32</td> <td>2147483648</td></tr> <tr><td>64-bit</td> <td>i64</td> <td>u64</td> <td>9223372036854776000</td></tr> <tr><td>arch</td> <td>isize</td> <td>usize</td> <td></td></tr></tbody></table> <p><code>arch</code>依赖计算机机构，32或64</p> <table><thead><tr><th>数字字面值</th> <th>例子</th></tr></thead> <tbody><tr><td>Decimal</td> <td>98__222</td></tr> <tr><td>Hex</td> <td>0xff</td></tr> <tr><td>Octal</td> <td>0o77</td></tr> <tr><td>Binary</td> <td>0b1111_0000</td></tr> <tr><td>Byte (u8 only)</td> <td>b'A'</td></tr></tbody></table> <p>除<code>byte</code>外，可加类型后缀，如<code>57u8</code></p> <p>可加<code>_</code>作分隔符，方便读数</p> <p>整型溢出：<code>u8</code>存放<code>256</code>；<code>debug</code>模式编译时会<code>panic</code>退出；<code>release</code>构建时，进行二进制补码，<code>256</code>变<code>0</code>,<code>257</code>变<code>1</code>，类推</p> <h4 id="浮点型"><a href="#浮点型" class="header-anchor">#</a> 浮点型</h4> <p><code>f32</code> 和 <code>f64</code>（默认）</p> <p><code>IEEE-754</code>标准，和js一样会出现精度问题<code>0.1 + 0.2 = 0.30000000000000004</code></p> <h4 id="布尔型"><a href="#布尔型" class="header-anchor">#</a> 布尔型</h4> <p><code>bool</code> = <code>true</code> + <code>false</code></p> <h4 id="字符类型"><a href="#字符类型" class="header-anchor">#</a> 字符类型</h4> <p><code>char</code> 由单引号指定，字符串由双引号指定</p> <p>大小四个字节，代表一个<code>Unicode</code></p> <h4 id="元祖"><a href="#元祖" class="header-anchor">#</a> 元祖</h4> <p>圆括号包裹，逗号分隔，各个元素类型可不同</p> <p>可解构赋值</p> <p>可通过<code>tuple.index</code>获取指定位置的元素</p> <div class="language-rs extra-class"><pre class="language-text"><code>let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup;
let x = tup.0
</code></pre></div><h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <p><code>[type; number]</code> 长度不可变，每个元素类型必须相同</p> <div class="language-rs extra-class"><pre class="language-text"><code>let a: [i32; 5] = [1, 2, 3, 4, 5];
let first = a[0];
</code></pre></div><h3 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h3> <p><code>fn</code>声明，命名规范<code>snake_case</code></p> <p>函数参数必须声明类型</p> <p>Rust 是一门基于表达式（expression-based）的语言</p> <p>语句 Statements：执行操作，没有返回值，有<code>;</code></p> <p>表达式 Expressions：计算并产生值，没有<code>;</code></p> <p>宏调用、函数调用、<code>{}</code>都是表达式</p> <div class="language-rs extra-class"><pre class="language-text"><code>let x = 5;
// y = 4
let y = {
    let x = 3;
    x + 1 // 没有; 返回4
};
</code></pre></div><p>函数的返回值 <code>-&gt;</code>声明类型</p> <div class="language-rs extra-class"><pre class="language-text"><code>fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></div><h3 id="控制流"><a href="#控制流" class="header-anchor">#</a> 控制流</h3> <p><code>if</code> <code>loop</code> <code>while</code> <code>for</code></p> <hr> <h2 id="所有权-ownership"><a href="#所有权-ownership" class="header-anchor">#</a> 所有权 ownership</h2> <p>栈 stack：后进先出，类似js里基本类型存放的位置</p> <p>堆 Heap：类似js里Object类型存放的位置，在堆上分配内存，返回指针</p> <p><strong>目的</strong>：</p> <p>管理堆数据。跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间</p> <p><strong>规则</strong>：</p> <ol><li><p>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量</p></li> <li><p>值有且只有一个所有者</p></li> <li><p>当所有者（变量）离开作用域，这个值将被丢弃</p></li></ol> <p><code>char</code>类型，大小确定，且不可变，编译时内容确定，文本被硬编码进最终的可执行文件中；</p> <p><code>String</code>类型，可变的，不确定的文本片段，需要在堆上分配一块在编译时大小未知的内存，即</p> <ul><li><p>在运行时箱操作系统请求内存 <code>String::from</code></p></li> <li><p>需要一个处理完<code>String</code>时将内存返回给操作系统的方法</p> <ol><li>垃圾回收，自动回收，开发者无需关心</li> <li>手动回收</li> <li>在变量离开作用域后自动释放内存</li></ol></li></ul> <div class="language-rs extra-class"><pre class="language-text"><code>{
    let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的
    // 使用 s
}   // 此作用域已结束，自动调`drop`方法释放内存
    // s 不再有效
</code></pre></div><h3 id="变量与数据的交互"><a href="#变量与数据的交互" class="header-anchor">#</a> 变量与数据的交互</h3> <p><code>RAII(Resource Acquisition Is Initialization)</code>资源获取即初始化：C++中在生命周期结束时释放资源的模式</p> <p>在复杂场景下的行为</p> <h4 id="移动"><a href="#移动" class="header-anchor">#</a> 移动</h4> <p>类似js里对引用类型的复制，其实是对指针的操作，即浅拷贝</p> <div class="language-rs extra-class"><pre class="language-text"><code>let s1 = String::from(&quot;hello&quot;);
let s2 = s1; // move移动，浅拷贝的同时使`s1`无效，内存的释放只看s2
</code></pre></div><h4 id="克隆"><a href="#克隆" class="header-anchor">#</a> 克隆</h4> <p>深复制</p> <div class="language-rs extra-class"><pre class="language-text"><code>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
</code></pre></div><p>存储在栈上的类型有一个叫做<code>Copy trait</code>的特殊注解，在将其赋值给其他变量后仍然可用</p> <h4 id="所有权与函数"><a href="#所有权与函数" class="header-anchor">#</a> 所有权与函数</h4> <div class="language-rs extra-class"><pre class="language-text"><code>fn main() {
    let s = String::from(&quot;hello&quot;);  // s 进入作用域
    takes_ownership(s); // s 的值移动到函数里
    // s到这里不再有效
    let x = 5;  // x 进入作用域
    makes_copy(x);  // x 应该移动函数里，
    // 但 i32 是 Copy 的，所以在后面可继续使用 x
} // x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!(&quot;{}&quot;, some_string);
} // some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!(&quot;{}&quot;, some_integer);
} // some_integer 移出作用域。不会有特殊操作
</code></pre></div><h4 id="返回值与作用域"><a href="#返回值与作用域" class="header-anchor">#</a> 返回值与作用域</h4> <p>函数的返回值也可以转移所有权</p> <div class="language-rs extra-class"><pre class="language-text"><code>fn main() {
    let s1 = gives_ownership(); // gives_ownership 将返回值移给 s1
    let s2 = String::from(&quot;hello&quot;); // s2 进入作用域
    let s3 = takes_and_gives_back(s2);  // s2 被移动到takes_and_gives_back 中, 它也将返回值移给 s3
} // s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String { // gives_ownership 将返回值移动给
    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.
    some_string // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域
    a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></div><p>需求：函数使用一个值，但不想获取所有权，因为后面还要用，同时还需要函数返回一些其他值</p> <h3 id="引用"><a href="#引用" class="header-anchor">#</a> 引用 &amp;</h3> <p><code>&amp;</code> 引用的值默认禁止修改</p> <div class="language-rs extra-class"><pre class="language-text"><code>// $s1 -&gt; s1 -&gt; 堆内存
fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1);
    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></div><p><strong>可变引用</strong>：<code>&amp;mut</code></p> <p>特定作用域中的特定数据有且只有一个可变引用，防止<em>数据竞争</em></p> <p>一个引用的作用域从声明的地方开始一直持续到最后一次使用为止</p> <div class="language-rs extra-class"><pre class="language-text"><code>let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s;
let r2 = &amp;s;
println!(&quot;{} and {}&quot;, r1, r2);
// r1 和 r2 最后一次使用，作用域结束

let r3 = &amp;mut s; // 作用域没有重叠，可声明可变引用
println!(&quot;{}&quot;, r3);
</code></pre></div><p><strong>悬垂指针（dangling pointer）</strong>：其指向的内存被分配给其它持有者</p> <div class="language-rs extra-class"><pre class="language-text"><code>fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);
    &amp;s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放，&amp;s为悬垂指针，此时应直接返回s，移出所有权，使s不被释放
</code></pre></div><h3 id="slice"><a href="#slice" class="header-anchor">#</a> slice</h3> <p><strong>slice</strong>：没有所有权的类型，是<code>String</code>中一部分值的引用</p> <div class="language-rs extra-class"><pre class="language-text"><code>let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[0..5];   // [0, 5)
let hello = &amp;s[...5];   // [0, 5)
let world = &amp;s[6..=10]; // [6, 10]
</code></pre></div><h2 id="结构体-struct"><a href="#结构体-struct" class="header-anchor">#</a> 结构体 struct</h2> <div class="language-rs extra-class"><pre class="language-text"><code>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
</code></pre></div><p><strong>元祖结构体</strong>：无字段名，只有字段类型 例<code>struct Color(i32, i32, i32);</code></p> <p><strong>类单元结构体</strong>：没有任何字段的结构体</p> <p>结构体无法直接通过<code>println!</code>打印出来，因为结构体没有<code>Display</code>实现，需要通过<code>{:?}</code>或<code>{:#?}</code>,还需要在结构体定义前显示声明<code>#[derive(Debug)]</code></p> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <p>定义在结构体、枚举或 trait 对象的上下文中的函数，第一个参数始终是<code>self</code>，即实例</p> <p>方法定义在<code>impl</code>块内</p> <p><strong>关联函数</strong>：<code>impl</code>块内不以<code>slef</code>作为参数的函数，常被用作返回一个结构体新实例的构造函数，通过<code>::</code>调用</p> <div class="language-rs extra-class"><pre class="language-text"><code>impl Rectangle {
    // 创建正方形
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
let sq = Rectangle::square(3);
</code></pre></div><p>结构体与方法有点类似js里的类和原型，结构体类似构造函数，方法类似原型链里的方法</p> <h2 id="枚举-enums"><a href="#枚举-enums" class="header-anchor">#</a> 枚举 enums</h2> <div class="language-rs extra-class"><pre class="language-text"><code>enum IpAddrKind {
    V4(u8, u8, u8, u8),
    V6(String)
}
impl InAddrKinf {
    fn my_fn(&amp;self) {
        // 定义方法
    }
}
// IpAddrKind::V4(127, 0, 0, 0, 1)
</code></pre></div><h3 id="option-枚举"><a href="#option-枚举" class="header-anchor">#</a> Option 枚举</h3> <p>避免空值</p> <div class="language-rs extra-class"><pre class="language-text"><code>enum Option&lt;T&gt; {
    Some(T),
    None
}
</code></pre></div><h3 id="match-控制流运算符"><a href="#match-控制流运算符" class="header-anchor">#</a> match 控制流运算符</h3> <p>功能上类似<code>switch case</code></p> <div class="language-rs extra-class"><pre class="language-text"><code>// 硬币分类
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25
    }
}
</code></pre></div><h3 id="if-let-语法糖"><a href="#if-let-语法糖" class="header-anchor">#</a> <code>if let</code> 语法糖</h3> <p>当分支小于两个时，类似<code>switch</code>转成<code>if else</code></p> <div class="language-rs extra-class"><pre class="language-text"><code>let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
// 简写
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
} else {
    // ...
}
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">修改于:</span> <span class="time">11/11/2019, 11:29:01 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/essay/前端代码埋点实践.html" class="prev">前端代码埋点实践</a></span> <span class="next"><a href="/essay/Rust系列（二）.html">Rust系列（二）</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3b644823.js" defer></script><script src="/assets/js/2.e997199f.js" defer></script><script src="/assets/js/30.a266a056.js" defer></script>
  </body>
</html>
