(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{232:function(t,s,a){"use strict";a.r(s);var e=a(0),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"rust系列（一）：从零开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rust系列（一）：从零开始"}},[t._v("#")]),t._v(" Rust系列（一）：从零开始")]),t._v(" "),a("h2",{attrs:{id:"windows安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#windows安装"}},[t._v("#")]),t._v(" Windows安装")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("官网"),a("a",{attrs:{href:"https://www.rust-lang.org/zh-CN/tools/install",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.rust-lang.org/zh-CN/tools/install"),a("OutboundLink")],1),t._v("安装"),a("code",[t._v("rust-init.exe")])])]),t._v(" "),a("li",[a("p",[t._v("国内环境直接安装会很慢甚至超时，需要增加两个环境变量")]),t._v(" "),a("p",[a("code",[t._v("RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup")])]),t._v(" "),a("p",[a("code",[t._v("RUSTUP_UPDATE_ROOT=http://mirrors.ustc.edu.cn/rust-static/rustup")])])]),t._v(" "),a("li",[a("p",[t._v("验证是否安装成功 "),a("code",[t._v("rustc --version")])])]),t._v(" "),a("li",[a("p",[t._v("crates镜像")]),t._v(" "),a("p",[t._v("类似npm的镜像，提高下依赖时的速度，在"),a("code",[t._v("C:\\Users\\Administrator\\.cargo")]),t._v("里新建"),a("code",[t._v("config")]),t._v("文件")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("source.crates-io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nregistry "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"https://github.com/rust-lang/crates.io-index"')]),t._v("\nreplace-with "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ustc'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("source.ustc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\nregistry "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"git://mirrors.ustc.edu.cn/crates.io-index"')]),t._v("\n")])])])])]),t._v(" "),a("h2",{attrs:{id:"新建项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新建项目"}},[t._v("#")]),t._v(" 新建项目")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("编译")]),t._v(" "),a("p",[t._v("新建"),a("code",[t._v("hello_world.rs")]),t._v("文件")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n  printn!("Hello World!")\n}\n')])])]),a("p",[t._v("命令行执行"),a("code",[t._v("rustc hello_world.rs")]),t._v("，生成两个文件"),a("code",[t._v("hello_world.exe")]),t._v("和"),a("code",[t._v("hello_world.pdd")])])]),t._v(" "),a("li",[a("p",[t._v("运行")]),t._v(" "),a("p",[a("code",[t._v(".pdd")]),t._v("包含调试信息，执行"),a("code",[t._v(".exe")]),t._v("，输出"),a("code",[t._v("Hello World!")])])])]),t._v(" "),a("h2",{attrs:{id:"cargo-构建系统和包管理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cargo-构建系统和包管理器"}},[t._v("#")]),t._v(" cargo 构建系统和包管理器")]),t._v(" "),a("p",[t._v("初始化项目")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo new hello_cargo\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" hello_cargo\n")])])]),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" .gitignore\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Cargo.toml\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("---.git\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("---src\n    main.rs\n")])])]),a("p",[t._v("通过 Cargo 构建")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo build\n")])])]),a("p",[t._v("发布构建")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo build --release\n")])])]),a("p",[t._v("编译并运行")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo run\n")])])]),a("p",[t._v("检查代码确保可编译")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo check\n")])])]),a("p",[t._v("更新依赖版本")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 只更新小版本 修改Cargo.lock文件")]),t._v("\ncargo update\n")])])]),a("p",[t._v("生成当前依赖的文档")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("cargo doc --open\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("h3",{attrs:{id:"注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[t._v("#")]),t._v(" 注释")]),t._v(" "),a("h4",{attrs:{id:"普通注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通注释"}},[t._v("#")]),t._v(" 普通注释")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 单行注释\n/* 多行注释 */\n")])])]),a("h4",{attrs:{id:"文档注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档注释"}},[t._v("#")]),t._v(" 文档注释")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/// 为下面的项生成帮助文档\n//! 为注释所属项生成帮助文档\n")])])]),a("h3",{attrs:{id:"格式化输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#格式化输出"}},[t._v("#")]),t._v(" 格式化输出")]),t._v(" "),a("p",[a("code",[t._v("std::fmt")]),t._v("里定义的一系列宏")]),t._v(" "),a("p",[a("code",[t._v("format!")]),t._v(","),a("code",[t._v("print!")]),t._v(","),a("code",[t._v("println!")]),t._v(","),a("code",[t._v("eprint!")]),t._v(","),a("code",[t._v("eprintln!")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("p",[t._v("几乎所有编程语言都共通的概念")]),t._v(" "),a("h3",{attrs:{id:"变量和可变性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量和可变性"}},[t._v("#")]),t._v(" 变量和可变性")]),t._v(" "),a("p",[a("code",[t._v("let")]),t._v(" 声明变量，默认不可变；"),a("code",[t._v("let mut")]),t._v("声明的变量可变")]),t._v(" "),a("p",[a("code",[t._v("const")]),t._v(" 声明常量")]),t._v(" "),a("p",[a("code",[t._v("shadowing")]),t._v(": 隐藏，多次定义同名变量，实际上创建了新的变量，可改变类型")]),t._v(" "),a("p",[a("code",[t._v("mut")]),t._v(": 未创建新变量，无法改变类型")]),t._v(" "),a("h3",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("p",[t._v("数据类型 = 标量 scalar + 复合 compound")]),t._v(" "),a("p",[t._v("标量 = 整型 + 浮点型 + 布尔类型 + 字符类型")]),t._v(" "),a("p",[t._v("复合 = 元祖 tuple + 数组 array")]),t._v(" "),a("h4",{attrs:{id:"整型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#整型"}},[t._v("#")]),t._v(" 整型")]),t._v(" "),a("p",[t._v("默认"),a("code",[t._v("i32")])]),t._v(" "),a("p",[t._v("范围"),a("code",[t._v("-2^(n - 1) 或 0 到 2(n - 1) - 1")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("长度")]),t._v(" "),a("th",[t._v("有符号")]),t._v(" "),a("th",[t._v("无符号")]),t._v(" "),a("th",[t._v("大小")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("8-bit")]),t._v(" "),a("td",[t._v("i8")]),t._v(" "),a("td",[t._v("u8")]),t._v(" "),a("td",[t._v("128")])]),t._v(" "),a("tr",[a("td",[t._v("16-bit")]),t._v(" "),a("td",[t._v("i16")]),t._v(" "),a("td",[t._v("u16")]),t._v(" "),a("td",[t._v("32768")])]),t._v(" "),a("tr",[a("td",[t._v("32-bit")]),t._v(" "),a("td",[t._v("i32")]),t._v(" "),a("td",[t._v("u32")]),t._v(" "),a("td",[t._v("2147483648")])]),t._v(" "),a("tr",[a("td",[t._v("64-bit")]),t._v(" "),a("td",[t._v("i64")]),t._v(" "),a("td",[t._v("u64")]),t._v(" "),a("td",[t._v("9223372036854776000")])]),t._v(" "),a("tr",[a("td",[t._v("arch")]),t._v(" "),a("td",[t._v("isize")]),t._v(" "),a("td",[t._v("usize")]),t._v(" "),a("td")])])]),t._v(" "),a("p",[a("code",[t._v("arch")]),t._v("依赖计算机机构，32或64")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("数字字面值")]),t._v(" "),a("th",[t._v("例子")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Decimal")]),t._v(" "),a("td",[t._v("98__222")])]),t._v(" "),a("tr",[a("td",[t._v("Hex")]),t._v(" "),a("td",[t._v("0xff")])]),t._v(" "),a("tr",[a("td",[t._v("Octal")]),t._v(" "),a("td",[t._v("0o77")])]),t._v(" "),a("tr",[a("td",[t._v("Binary")]),t._v(" "),a("td",[t._v("0b1111_0000")])]),t._v(" "),a("tr",[a("td",[t._v("Byte (u8 only)")]),t._v(" "),a("td",[t._v("b'A'")])])])]),t._v(" "),a("p",[t._v("除"),a("code",[t._v("byte")]),t._v("外，可加类型后缀，如"),a("code",[t._v("57u8")])]),t._v(" "),a("p",[t._v("可加"),a("code",[t._v("_")]),t._v("作分隔符，方便读数")]),t._v(" "),a("p",[t._v("整型溢出："),a("code",[t._v("u8")]),t._v("存放"),a("code",[t._v("256")]),t._v("；"),a("code",[t._v("debug")]),t._v("模式编译时会"),a("code",[t._v("panic")]),t._v("退出；"),a("code",[t._v("release")]),t._v("构建时，进行二进制补码，"),a("code",[t._v("256")]),t._v("变"),a("code",[t._v("0")]),t._v(","),a("code",[t._v("257")]),t._v("变"),a("code",[t._v("1")]),t._v("，类推")]),t._v(" "),a("h4",{attrs:{id:"浮点型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮点型"}},[t._v("#")]),t._v(" 浮点型")]),t._v(" "),a("p",[a("code",[t._v("f32")]),t._v(" 和 "),a("code",[t._v("f64")]),t._v("（默认）")]),t._v(" "),a("p",[a("code",[t._v("IEEE-754")]),t._v("标准，和js一样会出现精度问题"),a("code",[t._v("0.1 + 0.2 = 0.30000000000000004")])]),t._v(" "),a("h4",{attrs:{id:"布尔型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布尔型"}},[t._v("#")]),t._v(" 布尔型")]),t._v(" "),a("p",[a("code",[t._v("bool")]),t._v(" = "),a("code",[t._v("true")]),t._v(" + "),a("code",[t._v("false")])]),t._v(" "),a("h4",{attrs:{id:"字符类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符类型"}},[t._v("#")]),t._v(" 字符类型")]),t._v(" "),a("p",[a("code",[t._v("char")]),t._v(" 由单引号指定，字符串由双引号指定")]),t._v(" "),a("p",[t._v("大小四个字节，代表一个"),a("code",[t._v("Unicode")])]),t._v(" "),a("h4",{attrs:{id:"元祖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元祖"}},[t._v("#")]),t._v(" 元祖")]),t._v(" "),a("p",[t._v("圆括号包裹，逗号分隔，各个元素类型可不同")]),t._v(" "),a("p",[t._v("可解构赋值")]),t._v(" "),a("p",[t._v("可通过"),a("code",[t._v("tuple.index")]),t._v("获取指定位置的元素")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let tup: (i32, f64, u8) = (500, 6.4, 1);\nlet (x, y, z) = tup;\nlet x = tup.0\n")])])]),a("h4",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[a("code",[t._v("[type; number]")]),t._v(" 长度不可变，每个元素类型必须相同")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a: [i32; 5] = [1, 2, 3, 4, 5];\nlet first = a[0];\n")])])]),a("h3",{attrs:{id:"函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),a("p",[a("code",[t._v("fn")]),t._v("声明，命名规范"),a("code",[t._v("snake_case")])]),t._v(" "),a("p",[t._v("函数参数必须声明类型")]),t._v(" "),a("p",[t._v("Rust 是一门基于表达式（expression-based）的语言")]),t._v(" "),a("p",[t._v("语句 Statements：执行操作，没有返回值，有"),a("code",[t._v(";")])]),t._v(" "),a("p",[t._v("表达式 Expressions：计算并产生值，没有"),a("code",[t._v(";")])]),t._v(" "),a("p",[t._v("宏调用、函数调用、"),a("code",[t._v("{}")]),t._v("都是表达式")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let x = 5;\n// y = 4\nlet y = {\n    let x = 3;\n    x + 1 // 没有; 返回4\n};\n")])])]),a("p",[t._v("函数的返回值 "),a("code",[t._v("->")]),t._v("声明类型")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn five() -> i32 {\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!("The value of x is: {}", x);\n}\n')])])]),a("h3",{attrs:{id:"控制流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制流"}},[t._v("#")]),t._v(" 控制流")]),t._v(" "),a("p",[a("code",[t._v("if")]),t._v(" "),a("code",[t._v("loop")]),t._v(" "),a("code",[t._v("while")]),t._v(" "),a("code",[t._v("for")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"所有权-ownership"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有权-ownership"}},[t._v("#")]),t._v(" 所有权 ownership")]),t._v(" "),a("p",[t._v("栈 stack：后进先出，类似js里基本类型存放的位置")]),t._v(" "),a("p",[t._v("堆 Heap：类似js里Object类型存放的位置，在堆上分配内存，返回指针")]),t._v(" "),a("p",[a("strong",[t._v("目的")]),t._v("：")]),t._v(" "),a("p",[t._v("管理堆数据。跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间")]),t._v(" "),a("p",[a("strong",[t._v("规则")]),t._v("：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Rust 中的每一个值都有一个被称为其 所有者（owner）的变量")])]),t._v(" "),a("li",[a("p",[t._v("值有且只有一个所有者")])]),t._v(" "),a("li",[a("p",[t._v("当所有者（变量）离开作用域，这个值将被丢弃")])])]),t._v(" "),a("p",[a("code",[t._v("char")]),t._v("类型，大小确定，且不可变，编译时内容确定，文本被硬编码进最终的可执行文件中；")]),t._v(" "),a("p",[a("code",[t._v("String")]),t._v("类型，可变的，不确定的文本片段，需要在堆上分配一块在编译时大小未知的内存，即")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在运行时箱操作系统请求内存 "),a("code",[t._v("String::from")])])]),t._v(" "),a("li",[a("p",[t._v("需要一个处理完"),a("code",[t._v("String")]),t._v("时将内存返回给操作系统的方法")]),t._v(" "),a("ol",[a("li",[t._v("垃圾回收，自动回收，开发者无需关心")]),t._v(" "),a("li",[t._v("手动回收")]),t._v(" "),a("li",[t._v("在变量离开作用域后自动释放内存")])])])]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('{\n    let s = String::from("hello"); // 从此处起，s 是有效的\n    // 使用 s\n}   // 此作用域已结束，自动调`drop`方法释放内存\n    // s 不再有效\n')])])]),a("h3",{attrs:{id:"变量与数据的交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量与数据的交互"}},[t._v("#")]),t._v(" 变量与数据的交互")]),t._v(" "),a("p",[a("code",[t._v("RAII(Resource Acquisition Is Initialization)")]),t._v("资源获取即初始化：C++中在生命周期结束时释放资源的模式")]),t._v(" "),a("p",[t._v("在复杂场景下的行为")]),t._v(" "),a("h4",{attrs:{id:"移动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动"}},[t._v("#")]),t._v(" 移动")]),t._v(" "),a("p",[t._v("类似js里对引用类型的复制，其实是对指针的操作，即浅拷贝")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let s1 = String::from("hello");\nlet s2 = s1; // move移动，浅拷贝的同时使`s1`无效，内存的释放只看s2\n')])])]),a("h4",{attrs:{id:"克隆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#克隆"}},[t._v("#")]),t._v(" 克隆")]),t._v(" "),a("p",[t._v("深复制")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let s1 = String::from("hello");\nlet s2 = s1.clone();\n')])])]),a("p",[t._v("存储在栈上的类型有一个叫做"),a("code",[t._v("Copy trait")]),t._v("的特殊注解，在将其赋值给其他变量后仍然可用")]),t._v(" "),a("h4",{attrs:{id:"所有权与函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#所有权与函数"}},[t._v("#")]),t._v(" 所有权与函数")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let s = String::from("hello");  // s 进入作用域\n    takes_ownership(s); // s 的值移动到函数里\n    // s到这里不再有效\n    let x = 5;  // x 进入作用域\n    makes_copy(x);  // x 应该移动函数里，\n    // 但 i32 是 Copy 的，所以在后面可继续使用 x\n} // x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会有特殊操作\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n    println!("{}", some_string);\n} // some_string 移出作用域并调用 `drop` 方法。占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n    println!("{}", some_integer);\n} // some_integer 移出作用域。不会有特殊操作\n')])])]),a("h4",{attrs:{id:"返回值与作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回值与作用域"}},[t._v("#")]),t._v(" 返回值与作用域")]),t._v(" "),a("p",[t._v("函数的返回值也可以转移所有权")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn main() {\n    let s1 = gives_ownership(); // gives_ownership 将返回值移给 s1\n    let s2 = String::from("hello"); // s2 进入作用域\n    let s3 = takes_and_gives_back(s2);  // s2 被移动到takes_and_gives_back 中, 它也将返回值移给 s3\n} // s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，所以什么也不会发生。s1 移出作用域并被丢弃\n\nfn gives_ownership() -> String { // gives_ownership 将返回值移动给\n    let some_string = String::from("hello"); // some_string 进入作用域.\n    some_string // 返回 some_string 并移出给调用的函数\n}\n\n// takes_and_gives_back 将传入字符串并返回该值\nfn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域\n    a_string  // 返回 a_string 并移出给调用的函数\n}\n')])])]),a("p",[t._v("需求：函数使用一个值，但不想获取所有权，因为后面还要用，同时还需要函数返回一些其他值")]),t._v(" "),a("h3",{attrs:{id:"引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[t._v("#")]),t._v(" 引用 &")]),t._v(" "),a("p",[a("code",[t._v("&")]),t._v(" 引用的值默认禁止修改")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// $s1 -> s1 -> 堆内存\nfn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n')])])]),a("p",[a("strong",[t._v("可变引用")]),t._v("："),a("code",[t._v("&mut")])]),t._v(" "),a("p",[t._v("特定作用域中的特定数据有且只有一个可变引用，防止"),a("em",[t._v("数据竞争")])]),t._v(" "),a("p",[t._v("一个引用的作用域从声明的地方开始一直持续到最后一次使用为止")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let mut s = String::from("hello");\n\nlet r1 = &s;\nlet r2 = &s;\nprintln!("{} and {}", r1, r2);\n// r1 和 r2 最后一次使用，作用域结束\n\nlet r3 = &mut s; // 作用域没有重叠，可声明可变引用\nprintln!("{}", r3);\n')])])]),a("p",[a("strong",[t._v("悬垂指针（dangling pointer）")]),t._v("：其指向的内存被分配给其它持有者")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('fn dangle() -> &String {\n    let s = String::from("hello");\n    &s // 返回字符串 s 的引用\n} // 这里 s 离开作用域并被丢弃。其内存被释放，&s为悬垂指针，此时应直接返回s，移出所有权，使s不被释放\n')])])]),a("h3",{attrs:{id:"slice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#slice"}},[t._v("#")]),t._v(" slice")]),t._v(" "),a("p",[a("strong",[t._v("slice")]),t._v("：没有所有权的类型，是"),a("code",[t._v("String")]),t._v("中一部分值的引用")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let s = String::from("hello world");\nlet hello = &s[0..5];   // [0, 5)\nlet hello = &s[...5];   // [0, 5)\nlet world = &s[6..=10]; // [6, 10]\n')])])]),a("h2",{attrs:{id:"结构体-struct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构体-struct"}},[t._v("#")]),t._v(" 结构体 struct")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("struct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n")])])]),a("p",[a("strong",[t._v("元祖结构体")]),t._v("：无字段名，只有字段类型 例"),a("code",[t._v("struct Color(i32, i32, i32);")])]),t._v(" "),a("p",[a("strong",[t._v("类单元结构体")]),t._v("：没有任何字段的结构体")]),t._v(" "),a("p",[t._v("结构体无法直接通过"),a("code",[t._v("println!")]),t._v("打印出来，因为结构体没有"),a("code",[t._v("Display")]),t._v("实现，需要通过"),a("code",[t._v("{:?}")]),t._v("或"),a("code",[t._v("{:#?}")]),t._v(",还需要在结构体定义前显示声明"),a("code",[t._v("#[derive(Debug)]")])]),t._v(" "),a("h3",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("p",[t._v("定义在结构体、枚举或 trait 对象的上下文中的函数，第一个参数始终是"),a("code",[t._v("self")]),t._v("，即实例")]),t._v(" "),a("p",[t._v("方法定义在"),a("code",[t._v("impl")]),t._v("块内")]),t._v(" "),a("p",[a("strong",[t._v("关联函数")]),t._v("："),a("code",[t._v("impl")]),t._v("块内不以"),a("code",[t._v("slef")]),t._v("作为参数的函数，常被用作返回一个结构体新实例的构造函数，通过"),a("code",[t._v("::")]),t._v("调用")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("impl Rectangle {\n    // 创建正方形\n    fn square(size: u32) -> Rectangle {\n        Rectangle { width: size, height: size }\n    }\n}\nlet sq = Rectangle::square(3);\n")])])]),a("p",[t._v("结构体与方法有点类似js里的类和原型，结构体类似构造函数，方法类似原型链里的方法")]),t._v(" "),a("h2",{attrs:{id:"枚举-enums"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#枚举-enums"}},[t._v("#")]),t._v(" 枚举 enums")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enum IpAddrKind {\n    V4(u8, u8, u8, u8),\n    V6(String)\n}\nimpl InAddrKinf {\n    fn my_fn(&self) {\n        // 定义方法\n    }\n}\n// IpAddrKind::V4(127, 0, 0, 0, 1)\n")])])]),a("h3",{attrs:{id:"option-枚举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option-枚举"}},[t._v("#")]),t._v(" Option 枚举")]),t._v(" "),a("p",[t._v("避免空值")]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enum Option<T> {\n    Some(T),\n    None\n}\n")])])]),a("h3",{attrs:{id:"match-控制流运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#match-控制流运算符"}},[t._v("#")]),t._v(" match 控制流运算符")]),t._v(" "),a("p",[t._v("功能上类似"),a("code",[t._v("switch case")])]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 硬币分类\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter\n}\n\nfn value_in_cents(coin: Coin) -> u32 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25\n    }\n}\n")])])]),a("h3",{attrs:{id:"if-let-语法糖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-let-语法糖"}},[t._v("#")]),t._v(" "),a("code",[t._v("if let")]),t._v(" 语法糖")]),t._v(" "),a("p",[t._v("当分支小于两个时，类似"),a("code",[t._v("switch")]),t._v("转成"),a("code",[t._v("if else")])]),t._v(" "),a("div",{staticClass:"language-rs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let some_u8_value = Some(0u8);\nmatch some_u8_value {\n    Some(3) => println!("three"),\n    _ => (),\n}\n// 简写\nif let Some(3) = some_u8_value {\n    println!("three");\n} else {\n    // ...\n}\n')])])])])}),[],!1,null,null,null);s.default=_.exports}}]);